
# C++ 中三种智能指针的使用场景

## 1. `std::unique_ptr`
### 使用场景：
- **独占所有权**：`std::unique_ptr` 表示唯一所有权，意味着某个对象只能由一个 `unique_ptr` 管理，不能被复制。这种场景下，智能指针一旦离开其作用域，所管理的对象会被自动释放。
- **需要自动释放资源的对象**：当你需要一个动态分配的对象且不需要多个指针共享其所有权时，`std::unique_ptr` 是最佳选择。例如，创建一个大型对象，该对象只在当前函数中使用，函数结束后自动销毁。

#### 示例代码：
```cpp
// 独占所有权，`ptr` 离开作用域时自动销毁对象
std::unique_ptr<int> ptr = std::make_unique<int>(42);
```

#### 适用场景：
- 动态内存管理，但不需要共享所有权。
- 实现 RAII 模式
- 管理资源句柄或文件指针
## 2. `std::shared_ptr`
### 使用场景：
- **共享所有权**：`std::shared_ptr` 允许多个指针共享同一个对象的所有权，使用引用计数来管理对象的生命周期。当最后一个 `shared_ptr` 销毁时，所管理的对象才会被释放。
- **复杂数据结构**：在某些需要多个对象间相互引用的复杂场景中，例如图或树结构，`std::shared_ptr` 可以有效管理资源。

#### 示例代码：
```cpp
std::shared_ptr<int> ptr1 = std::make_shared<int>(42);
std::shared_ptr<int> ptr2 = ptr1;  // ptr1 和 ptr2 共享对象的所有权
```

#### 适用场景：
- 需要多个对象共享同一个资源，并希望在最后一个对象不再使用资源时自动释放资源。
- 在需要跨作用域共享动态对象的所有权时（如多线程中多个线程共享对象）。

## 3. `std::weak_ptr`
### 使用场景：
- **解决循环引用问题**：`std::weak_ptr` 是一种不增加引用计数的智能指针，主要用于避免 `std::shared_ptr` 在循环引用时无法释放资源的问题。当一个对象的生命周期依赖于另一个对象时，`std::weak_ptr` 可以提供一种弱引用的方式，防止循环依赖。
- **缓存和观察者模式**：在某些缓存机制或观察者模式中，`std::weak_ptr` 可以用来观察对象是否还存在，而不影响对象的生命周期。

#### 示例代码：
```cpp
std::shared_ptr<int> ptr1 = std::make_shared<int>(42);
std::weak_ptr<int> weakPtr = ptr1;  // weakPtr 不影响对象的生命周期

if (auto sharedPtr = weakPtr.lock()) {
    // 安全使用对象
} else {
    // 对象已经被销毁
}
```

#### 适用场景：
- 需要检测资源是否还存在，但不希望影响对象的生命周期。
- 在设计复杂的共享对象关系时，避免循环引用。
