{"message":"lifetime may not live long enough","code":null,"level":"error","spans":[{"file_name":"src/second_list.rs","byte_start":1346,"byte_end":1347,"line_start":59,"line_end":59,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"    fn next(&mut self) -> Option<Self::Item> {","highlight_start":13,"highlight_end":14}],"label":"let's call the lifetime of this reference `'1`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/second_list.rs","byte_start":1269,"byte_end":1271,"line_start":56,"line_end":56,"column_start":6,"column_end":8,"is_primary":false,"text":[{"text":"impl<'a, T> Iterator for IterMut<'a, T> {","highlight_start":6,"highlight_end":8}],"label":"lifetime `'a` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/second_list.rs","byte_start":1389,"byte_end":1407,"line_start":60,"line_end":60,"column_start":9,"column_end":27,"is_primary":true,"text":[{"text":"        self.next.as_mut().map(|node| {","highlight_start":9,"highlight_end":27}],"label":"argument requires that `'1` must outlive `'a`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider adding 'move' keyword before the nested closure","code":null,"level":"help","spans":[{"file_name":"src/second_list.rs","byte_start":1412,"byte_end":1412,"line_start":60,"line_end":60,"column_start":32,"column_end":32,"is_primary":true,"text":[{"text":"        self.next.as_mut().map(|node| {","highlight_start":32,"highlight_end":32}],"label":null,"suggested_replacement":"move ","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: lifetime may not live long enough\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/second_list.rs:60:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<'a, T> Iterator for IterMut<'a, T> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mlifetime `'a` defined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn next(&mut self) -> Option<Self::Item> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mlet's call the lifetime of this reference `'1`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m60\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        self.next.as_mut().map(|node| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9margument requires that `'1` must outlive `'a`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider adding 'move' keyword before the nested closure\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m60\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        self.next.as_mut().map(\u001b[0m\u001b[0m\u001b[38;5;10mmove \u001b[0m\u001b[0m|node| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[38;5;10m++++\u001b[0m\n\n"}
{"message":"closure requires unique access to `self.next` but it is already borrowed","code":{"code":"E0500","explanation":"A borrowed variable was used by a closure.\n\nErroneous code example:\n\n```compile_fail,E0500\nfn you_know_nothing(jon_snow: &mut i32) {\n    let nights_watch = &jon_snow;\n    let starks = || {\n        *jon_snow = 3; // error: closure requires unique access to `jon_snow`\n                       //        but it is already borrowed\n    };\n    println!(\"{}\", nights_watch);\n}\n```\n\nIn here, `jon_snow` is already borrowed by the `nights_watch` reference, so it\ncannot be borrowed by the `starks` closure at the same time. To fix this issue,\nyou can create the closure after the borrow has ended:\n\n```\nfn you_know_nothing(jon_snow: &mut i32) {\n    let nights_watch = &jon_snow;\n    println!(\"{}\", nights_watch);\n    let starks = || {\n        *jon_snow = 3;\n    };\n}\n```\n\nOr, if the type implements the `Clone` trait, you can clone it between\nclosures:\n\n```\nfn you_know_nothing(jon_snow: &mut i32) {\n    let mut jon_copy = jon_snow.clone();\n    let starks = || {\n        *jon_snow = 3;\n    };\n    println!(\"{}\", jon_copy);\n}\n```\n"},"level":"error","spans":[{"file_name":"src/second_list.rs","byte_start":1412,"byte_end":1418,"line_start":60,"line_end":60,"column_start":32,"column_end":38,"is_primary":true,"text":[{"text":"        self.next.as_mut().map(|node| {","highlight_start":32,"highlight_end":38}],"label":"closure construction occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/second_list.rs","byte_start":1389,"byte_end":1398,"line_start":60,"line_end":60,"column_start":9,"column_end":18,"is_primary":false,"text":[{"text":"        self.next.as_mut().map(|node| {","highlight_start":9,"highlight_end":18}],"label":"borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/second_list.rs","byte_start":1433,"byte_end":1442,"line_start":61,"line_end":61,"column_start":13,"column_end":22,"is_primary":false,"text":[{"text":"            self.next = (*node).next.as_deref_mut();","highlight_start":13,"highlight_end":22}],"label":"second borrow occurs due to use of `self.next` in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/second_list.rs","byte_start":1269,"byte_end":1271,"line_start":56,"line_end":56,"column_start":6,"column_end":8,"is_primary":false,"text":[{"text":"impl<'a, T> Iterator for IterMut<'a, T> {","highlight_start":6,"highlight_end":8}],"label":"lifetime `'a` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/second_list.rs","byte_start":1389,"byte_end":1407,"line_start":60,"line_end":60,"column_start":9,"column_end":27,"is_primary":false,"text":[{"text":"        self.next.as_mut().map(|node| {","highlight_start":9,"highlight_end":27}],"label":"argument requires that `self.next` is borrowed for `'a`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0500]\u001b[0m\u001b[0m\u001b[1m: closure requires unique access to `self.next` but it is already borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/second_list.rs:60:32\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<'a, T> Iterator for IterMut<'a, T> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mlifetime `'a` defined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m60\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        self.next.as_mut().map(|node| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mclosure construction occurs here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mborrow occurs here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12margument requires that `self.next` is borrowed for `'a`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            self.next = (*node).next.as_deref_mut();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12msecond borrow occurs due to use of `self.next` in closure\u001b[0m\n\n"}
{"message":"aborting due to 2 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 2 previous errors\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0500`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0500`.\u001b[0m\n"}
